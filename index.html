<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Tower Stacker</title>
<style>
  :root{--bg2:#111827;--ink:#e5e7eb;--muted:#9ca3af;--btn:#1f2937;--accent:#38bdf8;}
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:radial-gradient(120% 120% at 50% -10%, #1e293b 0%, var(--bg2) 60%, #0b1020 100%); color:var(--ink); font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif}
  .wrap{position:fixed; inset:0; display:grid; grid-template-rows:auto 1fr}
  header{display:flex; align-items:center; justify-content:space-between; gap:.75rem; padding:.6rem .8rem; background:linear-gradient(180deg, rgba(0,0,0,.35), rgba(0,0,0,.1)); border-bottom:1px solid rgba(255,255,255,.06); backdrop-filter:blur(6px)}
  .left{display:flex; align-items:baseline; gap:1rem; flex-wrap:wrap}
  .brand{font-weight:700}
  .hint{font-size:.85rem; color:var(--muted)}
  .stats{display:flex; gap:.6rem; align-items:center; flex-wrap:wrap}
  button{appearance:none; border:1px solid rgba(255,255,255,.12); background:var(--btn); color:var(--ink); padding:.45rem .7rem; border-radius:.6rem; font-weight:600; cursor:pointer}
  button:active{transform:translateY(1px)}
  #game{width:100%; height:100%; display:block; background:linear-gradient(180deg, rgba(56,189,248,.08), rgba(56,189,248,0) 30%)}
  .overlay{position:absolute; inset:0; display:grid; place-items:center; pointer-events:none}
  .card{pointer-events:auto; background:rgba(0,0,0,.55); border:1px solid rgba(255,255,255,.08); border-radius:1rem; padding:1rem 1.25rem; text-align:center; backdrop-filter:blur(8px); box-shadow:0 20px 40px rgba(0,0,0,.45)}
  .title{font-size:1.25rem; font-weight:800; margin:.25rem 0 .5rem}
  .sub{font-size:.95rem; color:var(--muted); margin-bottom:.9rem}
  .actions{display:flex; gap:.5rem; justify-content:center}
  .hidden{display:none}
  .pill{font-size:.85rem; padding:.15rem .45rem; border-radius:.5rem; background:rgba(56,189,248,.15); border:1px solid rgba(56,189,248,.35)}
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="left">
        <div class="brand">Tower Stacker</div>
        <div class="hint">Space/Tap drop Â· P pause</div>
      </div>
      <div class="stats">
        <span>Score: <b id="score">0</b></span>
        <span class="pill">Best: <b id="best">0</b></span>
        <button id="muteBtn" title="Mute (M)">ðŸ”Š</button>
        <button id="pauseBtn" title="Pause (P)">Pause</button>
        <button id="restartBtn" title="Restart (R)">Restart</button>
      </div>
    </header>

    <canvas id="game" aria-label="Tower Stacker game area"></canvas>

    <div id="over" class="overlay hidden" role="dialog" aria-modal="true">
      <div class="card">
        <div class="title">Game Over</div>
        <div class="sub">Height: <span id="finalScore">0</span> Â· Best: <span id="finalBest">0</span></div>
        <div class="actions"><button id="playAgain">Play again</button></div>
      </div>
    </div>
  </div>

<script>
(() => {
  // Canvas
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  let CW=0, CH=0, DPR=1;
  function resize(){
    DPR=Math.min(window.devicePixelRatio||1,2);
    CW=window.innerWidth; CH=window.innerHeight-document.querySelector('header').offsetHeight;
    canvas.width=Math.floor(CW*DPR); canvas.height=Math.floor(CH*DPR);
    canvas.style.width=CW+'px'; canvas.style.height=CH+'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  window.addEventListener('resize', resize, {passive:true}); resize();

  // UI refs
  const scoreEl = document.getElementById('score');
  const bestEl  = document.getElementById('best');
  const overEl  = document.getElementById('over');
  const finalScoreEl = document.getElementById('finalScore');
  const finalBestEl  = document.getElementById('finalBest');
  const pauseBtn = document.getElementById('pauseBtn');
  const muteBtn  = document.getElementById('muteBtn');
  document.getElementById('restartBtn').addEventListener('click', reset);
  document.getElementById('playAgain').addEventListener('click', reset);

  // Audio
  let audioCtx=null, muted=false;
  function ensureAudio(){ if(!audioCtx){ try{ audioCtx=new (window.AudioContext||window.webkitAudioContext)(); }catch{} } }
  function sfx(freq=440, ms=80, type='square', gain=0.03){
    if(muted || !audioCtx) return;
    const o=audioCtx.createOscillator(), g=audioCtx.createGain();
    o.type=type; o.frequency.value=freq; g.gain.value=gain; o.connect(g); g.connect(audioCtx.destination);
    o.start(); setTimeout(()=>{ g.gain.exponentialRampToValueAtTime(1e-4, audioCtx.currentTime+0.06); o.stop(audioCtx.currentTime+0.07); }, ms);
  }
  muteBtn.addEventListener('click', ()=>{ muted=!muted; muteBtn.textContent=muted?'ðŸ”‡':'ðŸ”Š'; });

  // Haptics
  const buzz = ms => ('vibrate' in navigator) && navigator.vibrate(ms);

  // Tunables
  const BLOCK_H=22, TOP_MARGIN=120;
  const PERFECT_EPS=3;
  const WIDEN_PERFECT=4;
  const GRAVITY=0.6;

  // Random speed ranges (px/frame @60fps, scaled by dt*60)
  const H_MIN=2.6, H_MAX=8.8;    // increased max horizontal speed
  const V_MIN=26,  V_MAX=60;     // increased max drop speed
  const PULSE_MAX=0.28;

  // State
  let blocks=[], mover=null, camY=0, score=0, best=Number(localStorage.getItem('ts_best')||0);
  let over=false, paused=false, state='idle', lastTime=0, timeSec=0, streak=0;
  let shards=[];
  bestEl.textContent=best;

  // Helpers
  const colorAt = n => `hsl(${(n*23)%360} 85% 60%)`;
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const rr=(x,y,w,h,r)=>{const t=Math.min(r,Math.abs(w)/2,Math.abs(h)/2);ctx.beginPath();ctx.moveTo(x+t,y);ctx.arcTo(x+w,y,x+w,y+h,t);ctx.arcTo(x+w,y+h,x,y+h,t);ctx.arcTo(x,y+h,x,y,t);ctx.arcTo(x,y,x+w,y,t);ctx.closePath();};
  const rnd=(a,b)=>a + Math.random()*(b-a);

  // Spawn/reset
  function reset(){
    over=false; paused=false; state='moving'; camY=0; score=0; streak=0; shards.length=0;
    scoreEl.textContent='0'; overEl.classList.add('hidden'); pauseBtn.textContent='Pause';
    blocks=[];
    const baseW=Math.max(140,Math.min(300,Math.floor(CW*0.6)));
    const baseX=(CW-baseW)/2, baseY=CH-BLOCK_H-8;
    blocks.push({x:baseX,y:baseY,w:baseW});
    spawnMover(baseW, baseY-BLOCK_H);
    lastTime=0; timeSec=0;
  }

  function spawnMover(width,y){
    // Slight global difficulty growth
    const diff = 1 + Math.min(0.8, score*0.02);
    mover={
      x: Math.random()<0.5 ? 0 : CW-width,
      y,
      w: width,
      dir: Math.random()<0.5 ? 1 : -1,
      color: colorAt(blocks.length),
      hspd: rnd(H_MIN,H_MAX) * diff,         // horizontal speed
      vspd: rnd(V_MIN,V_MAX) * diff,         // drop speed
      pulseAmp: Math.random()*PULSE_MAX,
      pulsePhase: Math.random()*Math.PI*2
    };
    state='moving';
  }

  // Input
  function drop(){ if(over||paused||!mover||state!=='moving')return; state='dropping'; }
  window.addEventListener('keydown', e=>{
    if(e.code==='Space'){ e.preventDefault(); ensureAudio(); over?reset():drop(); }
    else if(e.code==='KeyR'){ e.preventDefault(); reset(); }
    else if(e.code==='KeyP'){ e.preventDefault(); togglePause(); }
    else if(e.code==='KeyM'){ e.preventDefault(); muted=!muted; muteBtn.textContent=muted?'ðŸ”‡':'ðŸ”Š'; }
  });
  canvas.addEventListener('pointerdown', ()=>{ ensureAudio(); over?reset():drop(); });

  function togglePause(){
    if(over) return;
    paused=!paused;
    pauseBtn.textContent=paused?'Resume':'Pause';
    if(!paused){ lastTime=0; }
  }

  // Off-cuts + particles
  function addShard(x,y,w,h,vy=0,life=1,type='chunk',color='white'){ shards.push({x,y,w,h,vy,life,type,color}); }
  function burst(x,y,color){ for(let i=0;i<10;i++){ addShard(x,y,3,3,0,1,'particle',color); } }

  // Update
  function update(dt){
    if(over||paused) return;

    timeSec += dt;

    // camera
    const topY = Math.min(mover?mover.y:Infinity, blocks[blocks.length-1].y);
    const desired = Math.max(0, TOP_MARGIN - topY);
    camY += (desired - camY) * Math.min(1, 8*dt);

    // shards
    for(let i=shards.length-1;i>=0;i--){
      const s=shards[i];
      if(s.type==='chunk'){ s.vy += GRAVITY; s.y += s.vy; s.life -= dt*0.4; }
      else{ s.y += 40*dt*(Math.random()*2+0.5); s.life -= dt*1.4; }
      if(s.life<=0 || s.y-camY>CH+60) shards.splice(i,1);
    }

    if(!mover) return;

    if(state==='moving'){
      // wobble
      const wobble = 1 + mover.pulseAmp * Math.sin(2*timeSec + mover.pulsePhase);
      const spd = mover.hspd * wobble;
      mover.x += mover.dir * spd * dt * 60;
      if(mover.x<=0){mover.x=0; mover.dir=1;}
      if(mover.x+mover.w>=CW){mover.x=CW-mover.w; mover.dir=-1;}
    } else if(state==='dropping'){
      const targetY = blocks[blocks.length-1].y - BLOCK_H;
      mover.y += mover.vspd * dt * 60;
      if(mover.y >= targetY){
        mover.y = targetY;
        const prev = blocks[blocks.length-1];
        const left = Math.max(mover.x, prev.x);
        const right= Math.min(mover.x+mover.w, prev.x+prev.w);
        let overlap = right - left;

        const perfect = (Math.abs(mover.x - prev.x) <= PERFECT_EPS && Math.abs(mover.w - prev.w) <= PERFECT_EPS);
        if(perfect){ mover.x=prev.x; mover.w=prev.w; overlap=prev.w; }

        if (overlap <= 0){
          buzz(60); sfx(120,120,'sawtooth',0.05);
          gameOver();
        } else {
          if(!perfect){
            if(mover.x < prev.x){
              const w = prev.x - mover.x; if(w>2) addShard(mover.x, mover.y, w, BLOCK_H, -2, 1, 'chunk', mover.color);
            } else if(mover.x + mover.w > prev.x + prev.w){
              const w = (mover.x+mover.w) - (prev.x+prev.w); if(w>2) addShard(prev.x+prev.w, mover.y, w, BLOCK_H, -2, 1, 'chunk', mover.color);
            }
          }
          mover.x = left; mover.w = overlap;
          blocks.push({x:mover.x, y:mover.y, w:mover.w});
          score += 1; scoreEl.textContent=String(score);

          if(perfect){
            streak += 1;
            mover.w = clamp(mover.w + WIDEN_PERFECT, 10, prev.w);
            burst(mover.x + mover.w/2, mover.y - 6, mover.color);
            sfx(660,80,'triangle',0.04); buzz(20);
          } else { streak = 0; sfx(360,80,'square',0.03); }

          spawnMover(mover.w, mover.y - BLOCK_H);
        }
      }
    }
  }

  function gameOver(){
    over=true; state='over';
    finalScoreEl.textContent=String(score);
    if(score>best){ best=score; localStorage.setItem('ts_best', String(best)); }
    bestEl.textContent=best; finalBestEl.textContent=best;
    overEl.classList.remove('hidden');
  }

  // Draw
  function draw(){
    ctx.clearRect(0,0,CW,CH);

    // grid
    ctx.globalAlpha=.08; ctx.lineWidth=1; ctx.strokeStyle='#93c5fd';
    for(let i=0;i<5;i++){ const y=Math.floor(CH-(i+1)*80+(camY%80)); ctx.beginPath(); ctx.moveTo(0,y+.5); ctx.lineTo(CW,y+.5); ctx.stroke(); }
    ctx.globalAlpha=1;

    // guides
    const top = blocks[blocks.length-1];
    if(top){
      ctx.globalAlpha=.15; ctx.strokeStyle='#ffffff'; ctx.setLineDash([6,6]);
      ctx.beginPath(); ctx.moveTo(top.x,0); ctx.lineTo(top.x,CH); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(top.x+top.w,0); ctx.lineTo(top.x+top.w,CH); ctx.stroke();
      ctx.setLineDash([]); ctx.globalAlpha=1;
    }

    // placed
    for(let i=0;i<blocks.length;i++){
      const b=blocks[i], y=b.y - camY; if(y>CH) continue;
      ctx.fillStyle = i===0 ? '#334155' : colorAt(i);
      ctx.shadowColor='rgba(0,0,0,.35)'; ctx.shadowBlur=10; rr(b.x,y,b.w,BLOCK_H,6); ctx.fill(); ctx.shadowBlur=0;
    }

    // mover
    if(mover){
      const y=mover.y - camY;
      ctx.fillStyle=mover.color;
      ctx.shadowColor='rgba(0,0,0,.35)'; ctx.shadowBlur=10; rr(mover.x,y,mover.w,BLOCK_H,6); ctx.fill(); ctx.shadowBlur=0;
      if(state==='moving'){ ctx.globalAlpha=.6; ctx.fillStyle='rgba(255,255,255,.2)'; rr(mover.x,y-6,mover.w,4,2); ctx.fill(); ctx.globalAlpha=1; }
    }

    // shards
    for(const s of shards){
      ctx.globalAlpha = clamp(s.life,0,1);
      ctx.fillStyle = s.color || '#fff';
      rr(s.x, s.y - camY, s.w, s.h, 2); ctx.fill();
    }
    ctx.globalAlpha=1;
  }

  // Loop
  function loop(t){
    if(!lastTime) lastTime=t;
    const dt = paused ? 0 : Math.min(0.05,(t-lastTime)/1000);
    lastTime=t;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  // Start
  reset();
  requestAnimationFrame(loop);

  // Pause button
  function togglePause(){
    if(over) return;
    paused=!paused;
    pauseBtn.textContent=paused?'Resume':'Pause';
    if(!paused){ lastTime=0; }
  }
  pauseBtn.addEventListener('click', togglePause);
})();
</script>
</body>
</html>
